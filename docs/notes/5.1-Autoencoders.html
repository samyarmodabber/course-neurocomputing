<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.175">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Neurocomputing - 13&nbsp; Autoencoders</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../notes/5.2-RBM.html" rel="next">
<link href="../notes/4.3-SemanticSegmentation.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-title">Autoencoders</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Neurocomputing</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/vitay/course-neurocomputing" title="Source Code" class="sidebar-tool px-1"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">Overview</a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">Introduction</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/1.1-Introduction.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/1.2-Math.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Math basics (optional)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/1.3-Neurons.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Neurons</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">Linear algorithms</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/2.1-Optimization.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Optimization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/2.2-LinearRegression.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Linear regression</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/2.3-LinearClassification.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Linear classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/2.4-LearningTheory.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Learning theory</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">Neural networks</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/3.1-NeuralNetworks.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Multi-layer perceptron</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/3.2-DNN.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Modern neural networks</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">Convolutional neural networks</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/4.1-CNN.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Convolutional neural networks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/4.2-ObjectDetection.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Object detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/4.3-SemanticSegmentation.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Semantic segmentation</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">Unsupervised learning and generative modeling</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/5.1-Autoencoders.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Autoencoders</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/5.2-RBM.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Restricted Boltzmann machines (optional)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/5.3-GAN.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Generative adversarial networks</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">Recurrent neural networks</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/6.1-RNN.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Recurrent neural networks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/6.2-Attention.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Attentional neural networks</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true">Self-supervised learning</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/7.1-Transformers.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Transformers</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/7.2-ContrastiveLearning.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Contrastive Learning</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true">Outlook</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/8.1-Limits.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Limits of deep learning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/8.2-Beyond.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Beyond Deep Learning</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">Exercises</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/Content.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">List of exercises</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/1-Python-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Introduction To Python</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/2-Numpy-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Numpy and Matplotlib</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/3-LinearRegression-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Linear regression</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/4-MLR-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Multiple linear regression</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/5-Crossvalidation-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Cross-validation and polynomial regression</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/6-LinearClassification-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Linear classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/7-SoftmaxClassifier-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Softmax classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/8-MLP-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Multi-layer Perceptron</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/9-MNIST-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">MNIST classification using keras</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/10-CNN-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Convolutional neural networks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/11-TransferLearning-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Transfer learning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/12-VAE-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Variational autoencoder</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../exercises/13-RNN-solution.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Recurrent neural networks</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#autoencoders" id="toc-autoencoders" class="nav-link active" data-scroll-target="#autoencoders">Autoencoders</a></li>
  <li><a href="#stacked-autoencoders" id="toc-stacked-autoencoders" class="nav-link" data-scroll-target="#stacked-autoencoders">Stacked autoencoders</a></li>
  <li><a href="#deep-autoencoders" id="toc-deep-autoencoders" class="nav-link" data-scroll-target="#deep-autoencoders">Deep autoencoders</a>
  <ul class="collapse">
  <li><a href="#semi-supervised-learning" id="toc-semi-supervised-learning" class="nav-link" data-scroll-target="#semi-supervised-learning">Semi-supervised learning</a></li>
  <li><a href="#denoising-autoencoders" id="toc-denoising-autoencoders" class="nav-link" data-scroll-target="#denoising-autoencoders">Denoising autoencoders</a></li>
  <li><a href="#deep-clustering" id="toc-deep-clustering" class="nav-link" data-scroll-target="#deep-clustering">Deep clustering</a></li>
  </ul></li>
  <li><a href="#variational-autoencoders-vae" id="toc-variational-autoencoders-vae" class="nav-link" data-scroll-target="#variational-autoencoders-vae">Variational autoencoders (VAE)</a>
  <ul class="collapse">
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#architecture" id="toc-architecture" class="nav-link" data-scroll-target="#architecture">Architecture</a></li>
  <li><a href="#loss-function-of-a-vae" id="toc-loss-function-of-a-vae" class="nav-link" data-scroll-target="#loss-function-of-a-vae">Loss function of a VAE</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-title">Autoencoders</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<p>Slides: <a href="../slides/5.1-Autoencoders.html" target="_blank">html</a> <a href="../slides/pdf/5.1-Autoencoders.pdf" target="_blank">pdf</a></p>
<section id="autoencoders" class="level2">
<h2 class="anchored" data-anchor-id="autoencoders">Autoencoders</h2>
<p></p><div id="youtube-frame" style="position: relative; padding-bottom: 56.25%; /* 16:9 */ height: 0;"><iframe width="100%" height="" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/bW2jYMdaPZk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p></p>
<p><strong>Supervised learning</strong> algorithms need a lot of labeled data (with <span class="math inline">\(\mathbf{t}\)</span>) in order to learn classification/regression tasks, but labeled data is very expensive to obtain (experts, crowd sourcing). A “bad” algorithm trained with a lot of data will perform better than a “good” algorithm trained with few data.</p>
<blockquote class="blockquote">
<p>“It is not who has the best algorithm who wins, it is who has the most data.”</p>
</blockquote>
<p>Unlabeled data is only useful for <strong>unsupervised learning</strong>, but very cheap to obtain (camera, microphone, search engines). Can we combine efficiently both approaches? <strong>Self-taught learning</strong> or <strong>semi-supervised learning</strong>.</p>
<p>An <strong>autoencoder</strong> is a NN trying to learn the identity function <span class="math inline">\(f(\mathbf{x}) = \mathbf{x}\)</span> using a different number of neurons in the hidden layer than in the input layer.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/autoencoder3.png" class="img-fluid figure-img" style="width:35.0%"></p>
<p></p><figcaption class="figure-caption">Architecture of a shallow autoencoder.</figcaption><p></p>
</figure>
</div>
<p>An autoencoder minimizes the <strong>reconstruction loss</strong> between the input <span class="math inline">\(\mathbf{x}\)</span> and the reconstruction <span class="math inline">\(\mathbf{x'}\)</span>, for example the mse between the two vectors:</p>
<p><span class="math display">\[
    \mathcal{L}_\text{reconstruction}(\theta) = \mathbb{E}_{\mathbf{x} \in \mathcal{D}} [ ||\mathbf{x'} - \mathbf{x}||^2 ]
\]</span></p>
<p>An autoencoder uses <strong>unsupervised learning</strong>: the output data used for learning is the same as the input data: No need for labels!</p>
<p>By forcing the projection of the input data on a feature space with less dimensions (<strong>latent space</strong>), the network has to extract relevant <strong>features</strong> from the training data: Dimensionality reduction, compression.</p>
<p>If the latent space has more dimensions than the input space, we need to <strong>constrain</strong> the autoencoder so that it does not simply learn the identity mapping. Below is an example of a sparse autoencoder trained on natural images <span class="citation" data-cites="Olshausen1997">(<a href="../references.html#ref-Olshausen1997" role="doc-biblioref">Olshausen and Field, 1997</a>)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/result-autoencoder.png" class="img-fluid figure-img" style="width:80.0%"></p>
<p></p><figcaption class="figure-caption">Sparse autoencoder trained on natural images <span class="citation" data-cites="Olshausen1997">(<a href="../references.html#ref-Olshausen1997" role="doc-biblioref">Olshausen and Field, 1997</a>)</span>.</figcaption><p></p>
</figure>
</div>
<p>Inputs are taken from random natural images and cut in 10*10 patches. 100 features are extracted in the hidden layer. The autoencoder is said <strong>sparse</strong> because it uses <strong>L1-regularization</strong> to make sure that only a few neurons are active in the hidden layer for a particular image. The learned features look like what the first layer of a CNN would learn, except that there was no labels at all! Can we take advantage of this to pre-train a supervised network?</p>
</section>
<section id="stacked-autoencoders" class="level2">
<h2 class="anchored" data-anchor-id="stacked-autoencoders">Stacked autoencoders</h2>
<p>In supervised learning, deep neural networks suffer from many problems: local minima, vanishing gradients, long training times… All these problems are due to the fact that the weights are randomly initialized at the beginning of training. <strong>Pretraining</strong> the weights using unsupervised learning allows to start already close to a good solution: the network will need less steps to converge, the gradients will vanish less and less data will be needed to learn a particular supervised task.</p>
<p>Let’s try to learn a <strong>stacked autoencoder</strong> by learning <em>progressively</em> each feature vector.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/stacked-autoencoder.png" class="img-fluid figure-img" style="width:80.0%"></p>
<p></p><figcaption class="figure-caption">Architecture of the stacked autoencoder. Source: <a href="http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders" class="uri">http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders</a>.</figcaption><p></p>
</figure>
</div>
<p>Using unlabeled data, train an autoencoder to extract first-order features, freeze the weights and remove the decoder.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/stacked1.png" class="img-fluid figure-img" style="width:40.0%"></p>
<p></p><figcaption class="figure-caption">The first layer is trained using an autoencoder on the inputs. Source: <a href="http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders" class="uri">http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders</a>.</figcaption><p></p>
</figure>
</div>
<p>Train another autoencoder on the same unlabeled data, but using the previous latent space as input/output.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/stacked2.png" class="img-fluid figure-img" style="width:40.0%"></p>
<p></p><figcaption class="figure-caption">The second layer is trained using an autoencoder on the first layer. Source: <a href="http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders" class="uri">http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders</a>.</figcaption><p></p>
</figure>
</div>
<p>Repeat the operation as often as needed, and finish with a simple classifier using the labeled data.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/stacked3.png" class="img-fluid figure-img" style="width:40.0%"></p>
<p></p><figcaption class="figure-caption">The output layer is trained using supervised learning on the last hidden layer. Source: <a href="http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders" class="uri">http://ufldl.stanford.edu/wiki/index.php/Stacked_Autoencoders</a>.</figcaption><p></p>
</figure>
</div>
<p>This defines a <strong>stacked autoencoder</strong>, trained using <strong>Greedy layer-wise</strong> learning. Each layer progressively learns more and more complex features of the input data (edges - contour - forms - objects): <strong>feature extraction</strong>. This method allows to train a deep network on few labeled data: the network will not overfit, because the weights are already in the right region. It solves <strong>gradient vanishing</strong>, as the weights are already close to the optimal solution and will efficiently transmit the gradient backwards. One can keep the pre-trained weights fixed for the classification task or <strong>fine-tune</strong> all the weights as in a regular DNN.</p>
</section>
<section id="deep-autoencoders" class="level2">
<h2 class="anchored" data-anchor-id="deep-autoencoders">Deep autoencoders</h2>
<p></p><div id="youtube-frame" style="position: relative; padding-bottom: 56.25%; /* 16:9 */ height: 0;"><iframe width="100%" height="" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/daBrY1dmvn0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p></p>
<section id="semi-supervised-learning" class="level3">
<h3 class="anchored" data-anchor-id="semi-supervised-learning">Semi-supervised learning</h3>
<p>Autoencoders are not restricted to a single hidden layer.</p>
<ul>
<li>The <strong>encoder</strong> goes from the input space <span class="math inline">\(\mathbf{x}\)</span> to the latent space <span class="math inline">\(\mathbf{z}\)</span>.</li>
</ul>
<p><span class="math display">\[
    \mathbf{z} = g_\phi(\mathbf{x})
\]</span></p>
<ul>
<li>The <strong>decoder</strong> goes from the latent space <span class="math inline">\(\mathbf{z}\)</span> to the output space <span class="math inline">\(\mathbf{x'}\)</span>.</li>
</ul>
<p><span class="math display">\[
    \mathbf{x'} = f_\theta(\mathbf{z})
\]</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/autoencoder-architecture.png" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">Deep autoencoder. Source: <a href="https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html" class="uri">https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html</a>.</figcaption><p></p>
</figure>
</div>
<p>The <strong>latent space</strong> is a <strong>bottleneck</strong> layer of lower dimensionality, learning a compressed representation of the input which has to contain enough information in order to <strong>reconstruct</strong> the input. Both the encoder with weights <span class="math inline">\(\phi\)</span> and the decoder with weights <span class="math inline">\(\theta\)</span> try to minimize the <strong>reconstruction loss</strong>:</p>
<p><span class="math display">\[
\mathcal{L}_\text{reconstruction}(\theta, \phi) = \mathbb{E}_{\mathbf{x} \in \mathcal{D}} [ ||f_\theta(g_\phi(\mathbf{x})) - \mathbf{x}||^2 ]
\]</span></p>
<p>Learning is <strong>unsupervised</strong>: we only need input data.</p>
<p>The encoder and decoder can be anything: fully-connected, convolutional, recurrent, etc. When using convolutional layers, the decoder has to <strong>upsample</strong> the latent space: max-unpooling or transposed convolutions can be used as in segmentation networks.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/convolutionalAE.png" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">Deep convolutional autoencoder. Source: <span class="citation" data-cites="Guo2017">(<a href="../references.html#ref-Guo2017" role="doc-biblioref">Guo et al., 2017</a>)</span>.</figcaption><p></p>
</figure>
</div>
<p>In <strong>semi-supervised</strong> or <strong>self-taught</strong> learning, we can first train an autoencoder on huge amounts of unlabeled data, and then use the latent representations as an input to a shallow classifier on a small supervised dataset.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/semisupervised-autoencoder.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">The encoder of an unsupervised autoencoder can be used as a feature extractor for a classifier. Source: <a href="https://doi.org/10.1117/12.2303912" class="uri">https://doi.org/10.1117/12.2303912</a>.</figcaption><p></p>
</figure>
</div>
<p>A linear classifier might even be enough if the latent space is well trained. The weights of the encoder can be fine-tuned with backpropagation, or remain fixed.</p>
</section>
<section id="denoising-autoencoders" class="level3">
<h3 class="anchored" data-anchor-id="denoising-autoencoders">Denoising autoencoders</h3>
<p>A <strong>denoising autoencoder</strong> (DAE, <span class="citation" data-cites="Vincent2010">(<a href="../references.html#ref-Vincent2010" role="doc-biblioref">Vincent et al., 2010</a>)</span>) is trained with noisy inputs (some pixels are dropped) but perfect desired outputs. It learns to suppress that noise.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/denoisingautoencoder.png" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">Denoising autoencoder. Source: <a href="https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html" class="uri">https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html</a>.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/denoisingautoencoder-result.png" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">Denoising autoencoder. Source: <a href="https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html" class="uri">https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html</a>.</figcaption><p></p>
</figure>
</div>
</section>
<section id="deep-clustering" class="level3">
<h3 class="anchored" data-anchor-id="deep-clustering">Deep clustering</h3>
<p><strong>Clustering</strong> algorithms (k-means, Gaussian Mixture Models, spectral clustering, etc) can be applied in the latent space to group data points into clusters. If you are lucky, the clusters may even correspond to classes.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/deepclustering.jpg" class="img-fluid figure-img" style="width:90.0%"></p>
<p></p><figcaption class="figure-caption">Clustering can be applied on the latent representations. Source: <a href="doi:10.1007/978-3-030-32520-6_55" class="uri">doi:10.1007/978-3-030-32520-6_55</a>.</figcaption><p></p>
</figure>
</div>
</section>
</section>
<section id="variational-autoencoders-vae" class="level2">
<h2 class="anchored" data-anchor-id="variational-autoencoders-vae">Variational autoencoders (VAE)</h2>
<p></p><div id="youtube-frame" style="position: relative; padding-bottom: 56.25%; /* 16:9 */ height: 0;"><iframe width="100%" height="" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/XhBI14qOzXg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p></p>
<section id="motivation" class="level3">
<h3 class="anchored" data-anchor-id="motivation">Motivation</h3>
<p>Autoencoders are <strong>deterministic</strong>: after learning, the same input <span class="math inline">\(\mathbf{x}\)</span> will generate the same latent code <span class="math inline">\(\mathbf{z}\)</span> and the same reconstruction <span class="math inline">\(\mathbf{\tilde{x}}\)</span>. Sampling the latent space generally generates non-sense reconstructions, because an autoencoder only learns data samples, it does not learn the underlying <strong>probability distribution</strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/autoencoder-limits.png" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">Deterministic autoencoders do not regularize their latent space. Source: <a href="https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73" class="uri">https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73</a>.</figcaption><p></p>
</figure>
</div>
<p>The main problem of supervised learning is to get enough annotated data. Being able to generate <strong>new</strong> images similar to the training examples would be extremely useful (data augmentation).</p>
<p>In order for this to work, we need to <strong>regularize</strong> the latent space: Close points in the latent space should correspond to close images. “Classical” L1 or L2 regularization does not ensure the regularity of the latent space.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/vae-latentspace.png" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">Variational autoencoders do regularize their latent space. Source: <a href="https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73" class="uri">https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73</a>.</figcaption><p></p>
</figure>
</div>
</section>
<section id="architecture" class="level3">
<h3 class="anchored" data-anchor-id="architecture">Architecture</h3>
<p>The <strong>variational autoencoder</strong> (VAE) <span class="citation" data-cites="Kingma2013">(<a href="../references.html#ref-Kingma2013" role="doc-biblioref">Kingma and Welling, 2013</a>)</span> solves this problem by having the encoder represent the <strong>probability distribution</strong> <span class="math inline">\(q_\phi(\mathbf{z}|\mathbf{x})\)</span> instead of a point <span class="math inline">\(\mathbf{z}\)</span> in the latent space.</p>
<p>This probability distribution is then <strong>sampled</strong> to obtain a vector <span class="math inline">\(\mathbf{z}\)</span> that will be passed to the decoder <span class="math inline">\(p_\theta(\mathbf{z})\)</span>. The strong hypothesis is that the latent space follows a <strong>normal distribution</strong> with mean <span class="math inline">\(\mathbf{\mu_x}\)</span> and variance <span class="math inline">\(\mathbf{\sigma_x}^2\)</span>.</p>
<p><span class="math display">\[
    \mathbf{z} \sim \mathcal{N}(\mathbf{\mu_x}, \mathbf{\sigma_x}^2)
\]</span></p>
<p>The two vectors <span class="math inline">\(\mathbf{\mu_x}\)</span> and <span class="math inline">\(\mathbf{\sigma_x}^2\)</span> are the outputs of the encoder.</p>
<p>````{admonition} Sampling from a normal distribution</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/normaldistribution.svg" class="img-fluid figure-img" style="width:70.0%"></p>
<p></p><figcaption class="figure-caption">Sampling from a normal distribution.</figcaption><p></p>
</figure>
</div>
<p>The normal distribution <span class="math inline">\(\mathcal{N}(\mu, \sigma^2)\)</span> is fully defined by its two parameters:</p>
<ul>
<li><span class="math inline">\(\mu\)</span> is the mean of the distribution.</li>
<li><span class="math inline">\(\sigma^2\)</span> is its variance.</li>
</ul>
<p>The <strong>probability density function</strong> (pdf) of the normal distribution is defined by the Gaussian function:</p>
<p><span class="math display">\[
    f(x; \mu, \sigma) = \frac{1}{\sqrt{2\,\pi\,\sigma^2}} \, e^{-\displaystyle\frac{(x - \mu)^2}{2\,\sigma^2}}
\]</span></p>
<p>A sample <span class="math inline">\(x\)</span> will likely be close to <span class="math inline">\(\mu\)</span>, with a deviation defined by <span class="math inline">\(\sigma^2\)</span>. It can be obtained using a sample of the <strong>standard normal distribution</strong> <span class="math inline">\(\mathcal{N}(0, 1)\)</span>:</p>
<p><span class="math display">\[x = \mu + \sigma \, \xi \; \; \text{with} \; \xi \sim \mathcal{N}(0, 1)\]</span> ````</p>
<p>Architecture of the VAE:</p>
<ol type="1">
<li>The encoder <span class="math inline">\(q_\phi(\mathbf{z}|\mathbf{x})\)</span> outputs the parameters <span class="math inline">\(\mathbf{\mu_x}\)</span> and <span class="math inline">\(\mathbf{\sigma_x}^2\)</span> of a normal distribution <span class="math inline">\(\mathcal{N}(\mathbf{\mu_x}, \mathbf{\sigma_x}^2)\)</span>.</li>
<li>We sample one vector <span class="math inline">\(\mathbf{z}\)</span> from this distribution: <span class="math inline">\(\mathbf{z} \sim \mathcal{N}(\mathbf{\mu_x}, \mathbf{\sigma_x}^2)\)</span>.</li>
<li>The decoder <span class="math inline">\(p_\theta(\mathbf{z})\)</span> reconstructs the input.</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/vae-structure.png" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">Architecture of a variational autoencoder. Source: <a href="https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73" class="uri">https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73</a></figcaption><p></p>
</figure>
</div>
<p>Open questions:</p>
<ol type="1">
<li>Which loss should we use and how do we regularize?</li>
<li>Does backpropagation still work?</li>
</ol>
</section>
<section id="loss-function-of-a-vae" class="level3">
<h3 class="anchored" data-anchor-id="loss-function-of-a-vae">Loss function of a VAE</h3>
<p>The <strong>loss function</strong> used in a VAE is of the form:</p>
<p><span class="math display">\[
    \mathcal{L}(\theta, \phi) = \mathcal{L}_\text{reconstruction}(\theta, \phi) + \mathcal{L}_\text{regularization}(\phi)
\]</span></p>
<p>The first term is the usual <strong>reconstruction loss</strong> of an autoencoder which depends on both the encoder and the decoder. One could simply compute the <strong>mse</strong> (summed over all pixels) between the input and the reconstruction:</p>
<p><span class="math display">\[ \mathcal{L}_\text{reconstruction}(\theta, \phi) = \mathbb{E}_{\mathbf{x} \in \mathcal{D}, \mathbf{z} \sim q_\phi(\mathbf{z}|\mathbf{x})} [ ||p_\theta(\mathbf{z}) - \mathbf{x}||^2 ]\]</span></p>
<p>In the expectation, <span class="math inline">\(\mathbf{x}\)</span> is sampled from the dataset <span class="math inline">\(\mathcal{D}\)</span> while <span class="math inline">\(\mathbf{z}\)</span> is sampled from the encoder <span class="math inline">\(q_\phi(\mathbf{z}|\mathbf{x})\)</span>. In <span class="citation" data-cites="Kingma2013">(<a href="../references.html#ref-Kingma2013" role="doc-biblioref">Kingma and Welling, 2013</a>)</span>, pixels values are normalized between 0 and 1, the decoder uses the logistic activation function for its output layer and the binary cross-entropy loss function is used:</p>
<p><span class="math display">\[ \mathcal{L}_\text{reconstruction}(\theta, \phi) = \mathbb{E}_{\mathbf{x} \in \mathcal{D}, \mathbf{z} \sim q_\phi(\mathbf{z}|\mathbf{x})} [ - \log p_\theta(\mathbf{z})]\]</span></p>
<p>The justification comes from variational inference and evidence lower-bound optimization (ELBO) but is out of the scope of this lecture.</p>
<p>The second term is the <strong>regularization term</strong> for the latent space, which only depends on the encoder with weights <span class="math inline">\(\phi\)</span>:</p>
<p><span class="math display">\[
    \mathcal{L}_\text{regularization}(\phi) = \text{KL}(q_\phi(\mathbf{z}|\mathbf{x}) || \mathcal{N}(\mathbf{0}, \mathbf{1})) = \text{KL}(\mathcal{N}(\mathbf{\mu_x}, \mathbf{\sigma_x}^2) || \mathcal{N}(\mathbf{0}, \mathbf{1}))
\]</span></p>
<p>It is defined as the <strong>Kullback-Leibler divergence</strong> between the output of the encoder and the standard normal distribution <span class="math inline">\(\mathcal{N}(\mathbf{0}, \mathbf{1})\)</span>. Think of it as a statistical “distance” between the distribution <span class="math inline">\(q_\phi(\mathbf{z}|\mathbf{x})\)</span> and the distribution <span class="math inline">\(\mathcal{N}(\mathbf{0}, \mathbf{1})\)</span>. The principle is not very different from L2-regularization, where we want the weights to be as close as possible from 0. Here we want the encoder to be as close as possible from <span class="math inline">\(\mathcal{N}(\mathbf{0}, \mathbf{1})\)</span>.</p>
<p>Why do we want the latent distributions to be close from <span class="math inline">\(\mathcal{N}(\mathbf{0}, \mathbf{1})\)</span> for <strong>all</strong> inputs <span class="math inline">\(\mathbf{x}\)</span>? <span class="math display">\[
    \mathcal{L}(\theta, \phi) = \mathcal{L}_\text{reconstruction}(\theta, \phi) + \text{KL}(q_\phi(\mathbf{z}|\mathbf{x}) || \mathcal{N}(\mathbf{0}, \mathbf{1}))
\]</span></p>
<p>By forcing the distributions to be close, we avoid “holes” in the latent space: we can move smoothly from one distribution to another without generating <strong>non-sense</strong> reconstructions.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/vae-regularization.png" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">Regularizing the latent space by minimizing the KL with <span class="math inline">\(\mathcal{N}(0,1)\)</span> makes sure that we can smoothly travel in the latent space. Source: <a href="https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73" class="uri">https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73</a></figcaption><p></p>
</figure>
</div>
<p>`:::{.callout-note} To make <span class="math inline">\(q_\phi(\mathbf{z}|\mathbf{x})\)</span> close from <span class="math inline">\(\mathcal{N}(\mathbf{0}, \mathbf{1})\)</span>, one could minimize instead the Euclidian distance in the <strong>parameter space</strong>:</p>
<p><span class="math display">\[
    \mathcal{L}(\theta, \phi) = \mathcal{L}_\text{reconstruction}(\theta, \phi) +  (||\mathbf{\mu_x}||^2 + ||\mathbf{\sigma_x} - 1||^2)
\]</span></p>
<p>However, this does not consider the <strong>overlap</strong> between the distributions. The two pairs of distributions below have the same distance between their means (0 and 1) and the same variance (1 and 10 respectively). The distributions on the left are very different from each other, but the distance in the parameter space is the same.</p>
<p><img src="../slides/img/naturalgradient.png" class="img-fluid" data-fig-align="center"> :::`</p>
<p>```{admonition} Kullback-Leibler divergence</p>
<p>The <strong>KL divergence</strong> between two random distributions <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> measures the <strong>statistical distance</strong> between them. It describes, on average, how likely a sample from <span class="math inline">\(X\)</span> could come from <span class="math inline">\(Y\)</span>:</p>
<p><span class="math display">\[
    \text{KL}(X ||Y) = \mathbb{E}_{x \sim X}[- \log \frac{P(Y=x)}{P(X=x)}]
\]</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../slides/img/crossentropy.svg" class="img-fluid figure-img"></p>
</figure>
</div>
<p>When the two distributions are equal almost anywhere, the KL divergence is 0. Otherwise it is positive. <strong>Minimizing the KL divergence between two distributions makes them close in the statistical sense</strong>.</p>
<pre><code>
The advantage of minimizing the KL of $q_\phi(\mathbf{z}|\mathbf{x})$ with $\mathcal{N}(0, 1)$ is that the KL takes a **closed form**, i.e. there is no need to compute the expectation over all possible latent representations $\mathbf{z}$:

$$
    \mathcal{L}_\text{regularization}(\phi) = \text{KL}(q_\phi(\mathbf{z}|\mathbf{x}) || \mathcal{N}(\mathbf{0}, \mathbf{1})) = \mathbb{E}_{\mathbf{x} \in \mathcal{D}, \mathbf{z} \sim q_\phi(\mathbf{z}|\mathbf{x})}[- \log \frac{f_{0, 1}(\mathbf{z}|\mathbf{x})}{q_\phi(\mathbf{z}|\mathbf{x})}]
$$

If $\mathbf{\mu_x}$ and  $\mathbf{\sigma_x}$ have $K$ elements (dimension of the latent space), the KL can be expressed as:

$$
    \mathcal{L}_\text{regularization}(\phi) = \mathbb{E}_{\mathbf{x} \in \mathcal{D}}[\dfrac{1}{2} \, \sum_{k=1}^K (\mathbf{\sigma_x} + \mathbf{\mu_x}^2 -1 - \log \mathbf{\sigma_x})]
$$

The KL is very easy to differentiate w.r.t $\mathbf{\mu_x}$ and  $\mathbf{\sigma_x}$, i.e. w.r.t $\phi$! In practice, the encoder predicts the vectors $\mathbf{\mu_x}$ and $\Sigma_\mathbf{x} = \log \mathbf{\sigma_x}$, so the loss becomes:

$$
    \mathcal{L}_\text{regularization}(\phi) = \dfrac{1}{2} \, \sum_{k=1}^K (\exp \Sigma_\mathbf{x} + \mathbf{\mu_x}^2 -1 - \Sigma_\mathbf{x})
$$

See &lt;https://wiseodd.github.io/techblog/2016/12/10/variational-autoencoder/&gt; for the proof.

Regularization tends to create a "gradient" over the information encoded in the latent space.  A point of the latent space sampled between the means of two encoded distributions should be decoded in an image in between the two training images.

![A regularized latent space makes sure that reconstructions always make sense. Source:  &lt;https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73&gt;](../slides/img/vae-regularization2.png){width=80%}

### Reparameterization trick

The second problem is that backpropagation does not work through the sampling operation. It is easy to backpropagate the gradient of the loss function through the decoder until the sample $\mathbf{z}$. But how do you backpropagate to the outputs of the encoder: $\mathbf{\mu_x}$ and $\mathbf{\sigma_x}$?

![Architecture of a variational autoencoder. Source:  &lt;https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73&gt;](../slides/img/vae-structure.png){width=100%}

Modifying slightly $\mathbf{\mu_x}$ or $\mathbf{\sigma_x}$ may not change at all the sample $\mathbf{z} \sim \mathcal{N}(\mathbf{\mu_x}, \mathbf{\sigma_x}^2)$, so you cannot estimate any gradient.

$$\frac{\partial \mathbf{z}}{\partial \mathbf{\mu_x}} = \; ?$$

Backpropagation does not work through a **sampling** operation, because it is not differentiable. 

$$\mathbf{z} \sim \mathcal{N}(\mathbf{\mu_x}, \mathbf{\sigma_x}^2)$$

The **reparameterization trick** consists in taking a sample $\xi$ out of $\mathcal{N}(0, 1)$ and reconstruct $\mathbf{z}$ with:

$$\mathbf{z} = \mathbf{\mu_x} + \mathbf{\sigma_x} \, \xi \qquad \text{with} \qquad \xi \sim \mathcal{N}(0, 1)$$

![Architecture of a variational autoencoder with the reparameterization trick. Source:  &lt;https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73&gt;](../slides/img/vae-reparameterization.png){width=100%}

The sampled value $\xi \sim \mathcal{N}(0, 1)$ becomes just another input to the neural network.

![Architecture of a variational autoencoder with the reparameterization trick. Source:  &lt;https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73&gt;](../slides/img/vae-reparameterization2.png){width=100%}

It allows to transform $\mathbf{\mu_x}$ and $\mathbf{\sigma_x}$ into a sample $\mathbf{z}$ of $\mathcal{N}(\mathbf{\mu_x}, \mathbf{\sigma_x}^2)$:

$$\mathbf{z} = \mathbf{\mu_x} + \mathbf{\sigma_x} \, \xi$$

We do not need to backpropagate through $\xi$, as there is no parameter to learn! The neural network becomes differentiable end-to-end, backpropagation will work.


### Summary

A variational autoencoder is an autoencoder where the latent space represents a probability distribution $q_\phi(\mathbf{z} | \mathbf{x})$ using the mean $\mathbf{\mu_x}$ and standard deviation $\mathbf{\sigma_x}$ of a normal distribution. The latent space can be sampled to generate new images using the decoder $p_\theta(\mathbf{z})$. KL regularization and the reparameterization trick are essential to VAE.

VAE loss:

$$\begin{aligned}
    \mathcal{L}(\theta, \phi) &amp;= \mathcal{L}_\text{reconstruction}(\theta, \phi) + \mathcal{L}_\text{regularization}(\phi) \\
    &amp;= \mathbb{E}_{\mathbf{x} \in \mathcal{D}, \xi \sim \mathcal{N}(0, 1)} [ - \log p_\theta(\mathbf{\mu_x} + \mathbf{\sigma_x} \, \xi) + \dfrac{1}{2} \, \sum_{k=1}^K (\mathbf{\sigma_x} + \mathbf{\mu_x}^2 -1 - \log \mathbf{\sigma_x})] \\
\end{aligned}$$

![Principle of a VAE. Source:  &lt;https://ijdykeman.github.io/ml/2016/12/21/cvae.html&gt;](../slides/img/vae-structure.svg){width=70%}


The two main applications of VAEs in **unsupervised learning** are:

1. **Dimensionality reduction**: projecting high dimensional data (images) onto a smaller space, for example a 2D space for visualization.
2. **Generative modeling**: generating samples from the same distribution as the training data (data augmentation, deep fakes) by sampling on the manifold.

### Advanced VAE

#### DeepFake









DeepFakes now became very easy, you can for example find DeepFace here: &lt;https://github.com/iperov/DeepFaceLab&gt;.

![During training of a deepfake, **one** encoder and **two** decoders learns to reproduce the face of each person. Source:  &lt;https://www.alanzucconi.com/2018/03/14/understanding-the-technology-behind-deepfakes/&gt;](../slides/img/deepfakes_01.png){width=100%}


![When generating the deepfake, the decoder of person B is used on the latent representation of person A. Source:  &lt;https://www.alanzucconi.com/2018/03/14/understanding-the-technology-behind-deepfakes/&gt;](../slides/img/deepfakes_02.png){width=100%}


#### $\beta$-VAE


VAE does not use a regularization parameter to balance the reconstruction and regularization losses. What happens if you do?

$$\begin{aligned}
    \mathcal{L}(\theta, \phi) &amp;= \mathcal{L}_\text{reconstruction}(\theta, \phi) + \beta \, \mathcal{L}_\text{regularization}(\phi) \\
    &amp;= \mathbb{E}_{\mathbf{x} \in \mathcal{D}, \xi \sim \mathcal{N}(0, 1)} [ - \log p_\theta(\mathbf{\mu_x} + \mathbf{\sigma_x} \, \xi) + \dfrac{\beta}{2} \, \sum_{k=1}^K (\mathbf{\sigma_x} + \mathbf{\mu_x}^2 -1 - \log \mathbf{\sigma_x})] \\
\end{aligned}$$

Using $\beta &gt; 1$ puts emphasis on learning statistically independent latent factors.

The $\beta$-VAE [@Higgins2016] allows to **disentangle** the latent variables, i.e. manipulate them individually to vary only one aspect of the image (pose, color, gender, etc.).


![$\beta$-VAE trained on CelebA allows to disentangle skin color, age/gender or saturation by manipulating individual latent variables. [@Higgins2016].](../slides/img/betavae-results.png){width=100%}

:::{.callout-note}
See &lt;https://worldmodels.github.io/&gt; for a live demo in the RL context.
:::


#### VQ-VAE

Deepmind researchers proposed VQ-VAE-2 [@Razavi2019], a hierarchical VAE using vector-quantized priors able to generate high-resolution images.

![VQ-VAE-2 [@Razavi2019].](../slides/img/vqvae.png){width=100%}


![Faces generated by VQ-VAE-2 [@Razavi2019].](../slides/img/vqvae-results.png){width=100%}

#### Conditional variational autoencoder (CVAE)

What if we provide the labels to the encoder and the decoder during training?

![Conditional VAE. Source: &lt;https://ijdykeman.github.io/ml/2016/12/21/cvae.html&gt;](../slides/img/cvae-structure.svg){width=100%}

When trained with labels, the **conditional variational autoencoder** (CVAE [@Sohn2015]) becomes able to sample many images of the same class.

![Conditional VAE. Source: &lt;https://ijdykeman.github.io/ml/2016/12/21/cvae.html&gt;](../slides/img/cvae-generation.svg){width=100%}

CVAE allows to sample as many samples of a given class as we want: **data augmentation**.

![MNIST digits generated by a Conditional VAE. Source: &lt;https://ijdykeman.github.io/ml/2016/12/21/cvae.html&gt;](../slides/img/cvae-mnist.png){width=60%}

The condition does not need to be a label, it can be a shape or another image (passed through another encoder).

![CVAE conditioned on shapes. Source:  &lt;https://hci.iwr.uni-heidelberg.de/content/variational-u-net-conditional-appearance-and-shape-generation&gt;](../slides/img/cvae-shape.png){width=60%}

## Variational inference (optional)









### Learning probability distributions from samples

The input data $X$ comes from an unknown distribution $P(X)$. The training set $\mathcal{D}$ is formed by **samples** of that distribution. Learning the distribution of the data means learning a **parameterized distribution** $p_\theta(X)$ that is as close as possible from the true distribution $P(X)$. The parameterized distribution could be a family of known distributions (e.g. normal) or a neural network with a softmax output layer.

![Density estimation. Source: &lt;https://machinelearningmastery.com/probability-density-estimation/&gt;](../slides/img/kerneldensityestimation.png){width=80%}

This means that we want to minimize the KL between the two distributions:

$$\min_\theta \, \text{KL}(P(X) || p_\theta(X)) = \mathbb{E}_{x \sim P(X)} [- \log \dfrac{p_\theta(X=x)}{P(X=x)}]$$

The problem is that we do not know $P(X)$ as it is what we want to learn, so we cannot estimate the KL directly.

In supervised learning, we are learning the **conditional probability** $P(T | X)$ of the targets given the inputs, i.e. what is the probability of having the label $T=t$ given the input $X=x$. A NN with a softmax output layer represents the parameterized distribution $p_\theta(T | X)$. The KL between the two distributions is:

$$\text{KL}(P(T | X) || p_\theta(T | X)) = \mathbb{E}_{x, t \sim \mathcal{D}} [- \log \dfrac{p_\theta(T=t | X=x)}{P(T=t | X=x)}]$$

With the properties of the log, we know that the KL is the cross-entropy minus the entropy of the data:

$$\begin{aligned}
\text{KL}(P(T | X) || p_\theta(T | X)) &amp;= \mathbb{E}_{x, t \sim \mathcal{D}} [- \log p_\theta(T=t | X=x)]  - \mathbb{E}_{x, t \sim \mathcal{D}} [- \log P(T=t | X=x)] \\
&amp;\\
    &amp; = H(P(T | X), p_\theta(T |X)) - H(P(T|X)) \\
\end{aligned}$$

When we minimize the KL by applying gradient descent on the parameters $\theta$, only the cross-entropy will change, as the data does not depends on the model:

$$\begin{aligned}
\nabla_\theta \, \text{KL}(P(T | X) || p_\theta(T | X))  &amp; = \nabla_\theta \, H(P(T | X), p_\theta(T |X)) - \nabla_\theta \,  H(P(T|X)) \\
    &amp;\\
     &amp; = \nabla_\theta \, H(P(T | X), p_\theta(T |X)) \\
     &amp; \\
     &amp; = \nabla_\theta \, \mathbb{E}_{x, t \sim \mathcal{D}} [-  \log p_\theta(T=t | X=x) ]\\
\end{aligned}$$

Minimizing the cross-entropy (negative log likelihood) of the model on the data is the same as minimizing the KL between the two distributions in supervised learning! We were actually minimizing the KL all along.

When trying to learn the distribution $P(X)$ of the data directly, we could use the same trick:

$$\nabla_\theta \, \text{KL}(P(X) || p_\theta(X)) = \nabla_\theta \, H(P(X), p_\theta(X))  = \nabla_\theta \, \mathbb{E}_{x \sim X} [- \log p_\theta(X=x)]$$

i.e. maximize the log-likelihood of the model on the data $X$. If we use $N$ data samples to estimate the expectation, we notice that:

$$
\mathbb{E}_{x \sim X} [\log p_\theta(X=x)] \approx \dfrac{1}{N} \, \sum_{i=1}^N \log p_\theta(X=x_i) = \dfrac{1}{N} \, \log \prod_{i=1}^N p_\theta(X=x_i) = \dfrac{1}{N} \, \log L(\theta)
$$

is indeed the log-likelihood of the model on the data that we maximized in **maximum likelihood estimation**.

The problem is that images are **highly-dimensional** (one dimension per pixel), so we would need astronomical numbers of samples to estimate the gradient (once): **curse of dimensionality**. 


![Curse of dimensionality. Source: &lt;https://dibyaghosh.com/blog/probability/highdimensionalgeometry.html&gt;](../slides/img/cursedimensionality.png){width=100%}

MLE does not work well in high-dimensional spaces. We need to work in a much lower-dimensional space.


### Latent space

Images are not random samples of the pixel space: **natural images** are embedded in a much lower-dimensional space called a **manifold**. A manifold is a **locally Euclidian** topological space of lower dimension: The surface of the earth is locally flat and 2D, but globally spherical and 3D.

If we have a **generative model** telling us how a point on the manifold $z$ maps to the image space ($P(X | z)$), we would only need to learn the distribution of the data in the lower-dimensional **latent space**.


![Manifold. Source: &lt;https://en.wikipedia.org/wiki/Manifold&gt;](../slides/img/manifold.png){width=50%}

The low-dimensional **latent variables** $z$ are the actual cause for the observations $X$. Given a sample $z$ on the manifold, we can train a **generative model** $p_\theta(X | z)$ to recreate the input $X$. $p_\theta(X | z)$ is the **decoder**: given a latent representation $z$, what is the corresponding observation $X$?

![Latent variable. Source: &lt;https://blog.evjang.com/2016/08/variational-bayes.html&gt;](../slides/img/latentvariable.png){width=40%}

If we learn the distribution $p_\theta(z)$ of the manifold (latent space), we can infer the distribution of the data $p_\theta(X)$ using that model:

$$p_\theta(X) = \mathbb{E}_{z \sim p_\theta(z)} [p_\theta(X | z)] = \int_z p_\theta(X | z) \, p_\theta(z) \, dz$$

Problem: we do not know $p_\theta(z)$, as the only data we see is $X$: $z$ is called a **latent variable** because it explains the data but is hidden.

### Variational inference

To estimate $p_\theta(z)$, we could again marginalize over $X$:


$$p_\theta(z) = \mathbb{E}_{x \sim p_\theta(X)} [p_\theta(z | x)] = \int_x p_\theta(z | x) \, p_\theta(x) \, dx$$

$p_\theta(z | x)$ is the **encoder**: given an input $x \sim p_\theta(X)$, what is its latent representation $z$? The Bayes rule tells us:

$$p_\theta(z | x) = p_\theta(x |z) \, \dfrac{p_\theta(z)}{p_\theta(x)}$$

The posterior probability (encoder) $p_\theta(z | X)$ depends on the model (decoder) $p_\theta(X|z)$, the prior (assumption) $p_\theta(z)$ and the evidence (data) $p_\theta(X)$.

We get: 

$$p_\theta(z) = \mathbb{E}_{x \sim p_\theta(X)} [p_\theta(x |z) \, \dfrac{p_\theta(z)}{p_\theta(x)}]$$

The posterior is **untractable** as it would require to integrate over all possible inputs $x \sim p_\theta(X)$:

$$p_\theta(z) = \mathbb{E}_{x \sim p_\theta(X)} [p_\theta(x |z) \, \dfrac{p_\theta(z)}{p_\theta(x)}] = \int_x p_\theta(x |z) \, p_\theta(z) \, dx$$

**Variational inference** proposes to approximate the true encoder $p_\theta(z | x)$ by another parameterized distribution $q_\phi(z|x)$. 

![Variational inference approximates the encoder with another parameterized distribution. Source: &lt;https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html&gt;](../slides/img/VAE-graphical-model.png){width=100%}

The decoder $p_\theta(x |z)$ generates observations $x$ from a latent representation $x$ with parameters $\theta$. The encoder $q_\phi(z|x)$ estimates the latent representation $z$ of a generated observation $x$. It should approximate $p_\theta(z | x)$ with parameters $\phi$.


To make $q_\phi(z| X)$ close from $p_\theta(z | X)$, we minimize their KL divergence:

$$\begin{aligned}
\text{KL}(q_\phi(z|X) || p_\theta(z | X) ) &amp;= \mathbb{E}_{z \sim q_\phi(z|X)} [- \log \dfrac{p_\theta(z | X)}{q_\phi(z|X)}]\\
\end{aligned}$$

Note that we sample the latent representations from the learned encoder $q_\phi(z|X)$ (imagination). As $p_\theta(z | X) = p_\theta(X |z) \, \dfrac{p_\theta(z)}{p_\theta(X)}$, we get:

$$\begin{aligned}
\text{KL}(q_\phi(z|X) || p_\theta(z | X) ) &amp;= \mathbb{E}_{z \sim q_\phi(z|X)} [- \log \dfrac{p_\theta(X | z) \, p_\theta(z)}{q_\phi(z|X) \, p_\theta(X)}]\\
&amp;=\mathbb{E}_{z \sim q_\phi(z|X)} [- \log \dfrac{p_\theta(z)}{q_\phi(z|X)}] - \mathbb{E}_{z \sim q_\phi(z|X)} [- \log p_\theta(X)]  \\
&amp;+ \mathbb{E}_{z \sim q_\phi(z|X)} [- \log p_\theta(X | z)]\\
\end{aligned}$$

$p_\theta(X)$ does not depend on $z$, so its expectation w.r.t $z$ is constant:

$$\begin{aligned}
\text{KL}(q_\phi(z|X) || p_\theta(z | X) ) &amp;= \text{KL}(q_\phi(z|X) || p_\theta(z)) + \log p_\theta(X) + \mathbb{E}_{z \sim q_\phi(z|X)} [- \log p_\theta(X | z)]\\
\end{aligned}$$

We rearrange the terms:

$$\begin{aligned}
\log p_\theta(X) - \text{KL}(q_\phi(z|X) || p_\theta(z | X) ) &amp;=  - \mathbb{E}_{z \sim q_\phi(z|X)} [- \log p_\theta(X | z)] - \text{KL}(q_\phi(z|X) || p_\theta(z))\\
\end{aligned}$$

* Training the **encoder** means that we **minimize** $\text{KL}(q_\phi(z|X) || p_\theta(z | X) )$.
* Training the **decoder** means that we **maximize** $\log p_\theta(X)$ (log-likelihood of the model).
* Training the encoder and decoder together means that we **maximize**:

$$ \text{ELBO}(\theta, \phi) = \log p_\theta(X) - \text{KL}(q_\phi(z|X) || p_\theta(z | X) )$$

The KL divergence is always positive or equal to 0, so we have:

$$\text{ELBO}(\theta, \phi) \leq \log p_\theta(X)$$

This term is called  the **evidence lower bound** (ELBO): by maximizing it, we also maximize the untractable evidence $\log p_\theta(X)$, which is what we want to do. The trick is that the right-hand term of the equation gives us a tractable definition of the ELBO term:

$$\begin{aligned}
\text{ELBO}(\theta, \phi) &amp;=  \log p_\theta(X) - \text{KL}(q_\phi(z|X) || p_\theta(z | X) ) \\
&amp;\\
&amp;= - \mathbb{E}_{z \sim q_\phi(z|X)} [- \log p_\theta(X | z)] - \text{KL}(q_\phi(z|X) || p_\theta(z))
\end{aligned}$$

What happens when we **minimize** the negative ELBO? 

$$ \mathcal{L}(\theta, \phi) = - \text{ELBO}(\theta, \phi) = \mathbb{E}_{z \sim q_\phi(z|X)} [- \log p_\theta(X | z)] + \text{KL}(q_\phi(z|X) || p_\theta(z))$$

* $\mathbb{E}_{z \sim q_\phi(z|X)} [- \log p_\theta(X | z)]$ is the **reconstruction loss** of the decoder $p_\theta(X | z)$:

    * Given a sample $z$ of the encoder $q_\phi(z|X)$, minimize the negative log-likelihood of the reconstruction $p_\theta(X | z)$.

* $\text{KL}(q_\phi(z|X) || p_\theta(z))$ is the **regularization loss** for the encoder: 

    * The latent distribution $q_\phi(z|X)$ should be too far from the **prior** $p_\theta(z)$.

**Variational autoencoders** use $\mathcal{N}(0, 1)$ as a prior for the latent space, but any other prior could be used. 

$$\begin{aligned}
    \mathcal{L}(\theta, \phi) &amp;= \mathcal{L}_\text{reconstruction}(\theta, \phi) + \mathcal{L}_\text{regularization}(\phi) \\
    &amp;\\
    &amp;= \mathbb{E}_{\mathbf{x} \in \mathcal{D}, \mathbf{z} \sim q_\phi(\mathbf{z}|\mathbf{x})} [ - \log p_\theta(\mathbf{z})] + \text{KL}(q_\phi(\mathbf{z}|\mathbf{x}) || \mathcal{N}(\mathbf{0}, \mathbf{1}))\\
\end{aligned}$$

The reparameterization trick and the fact that the KL between normal distributions has a closed form allow us to use backpropagation end-to-end. The encoder $q_\phi(z|X)$ and decoder $p_\theta(X | z)$ are neural networks in a VAE, but other parametrized distributions can be used (e.g. in physics).


```{admonition} Sources
* &lt;https://wiseodd.github.io/techblog/2016/12/10/variational-autoencoder/&gt;
* &lt;https://lilianweng.github.io/lil-log/2018/08/12/from-autoencoder-to-beta-vae.html&gt;
* &lt;https://blog.evjang.com/2016/08/variational-bayes.html&gt;
* &lt;https://jonathan-hui.medium.com/machine-learning-variational-inference-273d8e6480bb&gt;</code></pre>


<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography" style="display: none">
<div id="ref-Guo2017" class="csl-entry" role="doc-biblioentry">
Guo, X., Liu, X., Zhu, E., and Yin, J. (2017). Deep <span>Clustering</span> with <span>Convolutional Autoencoders</span>. in <em>Neural <span>Information Processing</span></em> Lecture <span>Notes</span> in <span>Computer Science</span>., eds. D. Liu, S. Xie, Y. Li, D. Zhao, and E.-S. M. El-Alfy (<span>Cham</span>: <span>Springer International Publishing</span>), 373–382. doi:<a href="https://doi.org/10.1007/978-3-319-70096-0_39">10.1007/978-3-319-70096-0_39</a>.
</div>
<div id="ref-Kingma2013" class="csl-entry" role="doc-biblioentry">
Kingma, D. P., and Welling, M. (2013). Auto-<span>Encoding Variational Bayes</span>. <em>arXiv:1312.6114 [cs]</em>. Available at: <a href="https://arxiv.org/abs/1312.6114">https://arxiv.org/abs/1312.6114</a>.
</div>
<div id="ref-Olshausen1997" class="csl-entry" role="doc-biblioentry">
Olshausen, B. A., and Field, D. J. (1997). Sparse coding with an overcomplete basis set: <span>A</span> strategy employed by <span>V1</span>? <em>Vision Research</em> 37, 3311–3325. doi:<a href="https://doi.org/10.1016/S0042-6989(97)00169-7">10.1016/S0042-6989(97)00169-7</a>.
</div>
<div id="ref-Vincent2010" class="csl-entry" role="doc-biblioentry">
Vincent, P., Larochelle, H., Lajoie, I., Bengio, Y., and Manzagol, P.-A. (2010). Stacked <span>Denoising Autoencoders</span>: <span>Learning Useful Representations</span> in a <span>Deep Network</span> with a <span>Local Denoising Criterion</span>. <em>Journal of Machine Learning Research</em>, 38.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="../notes/4.3-SemanticSegmentation.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Semantic segmentation</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../notes/5.2-RBM.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-title">Restricted Boltzmann machines (optional)</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>